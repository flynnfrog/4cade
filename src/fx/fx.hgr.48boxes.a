;license:MIT
;(c) 2020 by 4am & qkumba
;
!cpu 6502
!to "build/FX/BOXES48",plain
*=$6000

box      = $F8                       ; [byte]
stage    = $F9                       ; [byte]
any      = $FA                       ; [byte]
rowcount = $FB                       ; [byte]
src      = $FC                       ; [word]
dst      = $FE                       ; [word]
hgrlo    = $00                      ; [$C0 bytes]
hgrhi    = $300                      ; [$C0 bytes]
BoxStages = $C0                     ; [$30 bytes]

; recalculate HGR base addresses
; in:    X =  HGR row (00..BF)
; out:   preserves X, Y
;        clobbers A
!macro RECALC .copyflag {
         lda   hgrlo, x
!if .copyflag {
         sta   src
}
         sta   dst
         lda   hgrhi, x
         sta   dst+1
!if .copyflag {
         eor   #$60
         sta   src+1
}
}

; increase X by an arbitrary amount, and recalculate HGR base addresses
; clobbers A
!macro INX_BY .val, .copyflag {
         txa
         clc
         adc   #.val
         tax
         +RECALC .copyflag
}

; increase X, and recalculate HGR base addresses
!macro INX .copyflag {
         inx
         +RECALC .copyflag
}

; clear or copy 1 byte
!macro COPY .copyflag {
!if .copyflag {
         lda   (src), y
} else {
         lda   #0
}
         sta   (dst), y
}

; clear or copy certain bits based on bitmask
!macro MASKCOPY .mask, .copyflag {
         lda   (dst), y
!if .copyflag {
         eor   (src), y
}
         and   #.mask
         eor   (dst), y
         sta   (dst), y
}

!macro STAGE0 .copyflag {
         +INX_BY $0F, .copyflag
         iny
         iny
         +MASKCOPY %10111110, .copyflag
         +INX .copyflag
         +MASKCOPY %10111110, .copyflag
         rts
}

!macro STAGE1 .copyflag {
         +INX_BY $0E, .copyflag
         iny
         iny
         +COPY .copyflag
         +INX .copyflag
         +COPY .copyflag
         +INX .copyflag
         +COPY .copyflag
         +INX .copyflag
         +COPY .copyflag
         rts
}

!macro MIDDLE_STAGE .firstrow, .rowcount, .edgeleftmask, .edgerightmask, .leftmask, .rightmask, .copyflag {
         lda   #.rowcount
         sta   rowcount
         +INX_BY .firstrow, .copyflag
         iny
--
!if .edgeleftmask != .leftmask {
         +MASKCOPY .edgeleftmask, .copyflag
}
         iny
         +COPY .copyflag
!if .edgerightmask != .rightmask {
         iny
         +MASKCOPY .edgerightmask, .copyflag
         dey
}
         dey
-
         +MASKCOPY .leftmask, .copyflag
         iny
         iny
         +MASKCOPY .rightmask, .copyflag
         dey
         dey
         +INX .copyflag
         dec   rowcount
         beq   --
         bpl   -
         rts
}

!macro OUTER_STAGE .firstrow, .rowcount, .edgeleftmask, .edgerightmask, .leftmask, .rightmask, .copyflag {
         lda   #.rowcount
         sta   rowcount
         +INX_BY .firstrow, .copyflag
--
!if .edgeleftmask != .leftmask {
         +MASKCOPY .edgeleftmask, .copyflag
}
         iny
         +COPY .copyflag
         iny
         +COPY .copyflag
         iny
         +COPY .copyflag
!if .edgerightmask != .rightmask {
         iny
         +MASKCOPY .edgerightmask, .copyflag
         dey
}
         dey
         dey
         dey
-
         +MASKCOPY .leftmask, .copyflag
         iny
         iny
         iny
         iny
         +MASKCOPY .rightmask, .copyflag
         dey
         dey
         dey
         dey
         +INX .copyflag
         dec   rowcount
         beq   --
         bpl   -
         rts
}

         !source "src/fx/macros.a"

; actual code starts here

         +BUILD_HGR_LOOKUP_TABLES hgrlo, hgrhi
         ldx   #47
-        lda   BoxInitialStages, x
         sta   BoxStages, x
         dex
         bpl   -
MainLoop lda   #0
         sta   any
         ldx   #47
BoxLoop  stx   box
         lda   BoxStages, x          ; for each box, get its current stage
         bmi   NextBox               ; if stage >= $80, nothing to do
         tax
         lda   StagesHi, x
         beq   NextBox               ; if stage's drawing routine is 0, nothing to do
         sta   j+2
         lda   StagesLo, x
         sta   j+1
         ldx   box
         lda   BoxesX, x
         ldy   BoxesY, x             ; Y = starting byte offset for this box
         tax                         ; X = starting HGR row for this box
         inc   any
j        jsr   $FDFD                 ; [SMC] call drawing routine for this stage
NextBox  ldx   box
         inc   BoxStages, x          ; increment every box's stage every time through the loop,
                                     ; even if we didn't call a drawing routine
         dex
         bpl   BoxLoop
         lda   any
         beq   +                     ; if we didn't draw anything in any box, we're done
         bit   $C000
         bpl   MainLoop
+        rts

         !source "src/wait.a"

; box drawing routines for each stage
; in:    X = starting HGR row for this box
;        Y = starting byte offset for this box
clear00
         +STAGE0 0
clear01
         +STAGE1 0
clear02
         +MIDDLE_STAGE $0D, $05, %11000000, %10000001, %11000000, %10000001, 0
clear03
         +MIDDLE_STAGE $0C, $07, %11100000, %10000011, %10100000, %10000010, 0
clear04
         +MIDDLE_STAGE $0B, $09, %11110000, %10000111, %10010000, %10000100, 0
clear05
         +MIDDLE_STAGE $0A, $0B, %11111000, %10001111, %10001000, %10001000, 0
clear06
         +MIDDLE_STAGE $09, $0D, %11111100, %10011111, %10000100, %10010000, 0
clear07
         +MIDDLE_STAGE $08, $0F, %11111110, %10111111, %10000010, %10100000, 0
clear08
         +MIDDLE_STAGE $07, $11, %11111111, %11111111, %10000001, %11000000, 0
clear09
         +OUTER_STAGE  $06, $13, %11000000, %10000001, %11000000, %10000001, 0
clear0A
         +OUTER_STAGE  $05, $15, %11100000, %10000011, %10100000, %10000010, 0
clear0B
         +OUTER_STAGE  $04, $17, %11110000, %10000111, %10010000, %10000100, 0
clear0C
         +OUTER_STAGE  $03, $19, %11111000, %10001111, %10001000, %10001000, 0
clear0D
         +OUTER_STAGE  $02, $1B, %11111100, %10011111, %10000100, %10010000, 0
clear0E
         +OUTER_STAGE  $01, $1D, %11111110, %10111111, %10000010, %10100000, 0
clear0F
         +OUTER_STAGE  $00, $1F, %11111111, %11111111, %10000001, %11000000, 0
copy00
         +STAGE0 1
copy01
         +STAGE1 1
copy02
         +MIDDLE_STAGE $0D, $05, %11000000, %10000001, %11000000, %10000001, 1
copy03
         +MIDDLE_STAGE $0C, $07, %11100000, %10000011, %10100000, %10000010, 1
copy04
         +MIDDLE_STAGE $0B, $09, %11110000, %10000111, %10010000, %10000100, 1
copy05
         +MIDDLE_STAGE $0A, $0B, %11111000, %10001111, %10001000, %10001000, 1
copy06
         +MIDDLE_STAGE $09, $0D, %11111100, %10011111, %10000100, %10010000, 1
copy07
         +MIDDLE_STAGE $08, $0F, %11111110, %10111111, %10000010, %10100000, 1
copy08
         +MIDDLE_STAGE $07, $11, %11111111, %11111111, %10000001, %11000000, 1
copy09
         +OUTER_STAGE  $06, $13, %11000000, %10000001, %11000000, %10000001, 1
copy0A
         +OUTER_STAGE  $05, $15, %11100000, %10000011, %10100000, %10000010, 1
copy0B
         +OUTER_STAGE  $04, $17, %11110000, %10000111, %10010000, %10000100, 1
copy0C
         +OUTER_STAGE  $03, $19, %11111000, %10001111, %10001000, %10001000, 1
copy0D
         +OUTER_STAGE  $02, $1B, %11111100, %10011111, %10000100, %10010000, 1
copy0E
         +OUTER_STAGE  $01, $1D, %11111110, %10111111, %10000010, %10100000, 1
copy0F
         +OUTER_STAGE  $00, $1F, %11111111, %11111111, %10000001, %11000000, 1

;
; Boxes are laid out in a grid, left-to-right, top-down:
; 0  1  2  3  4  5  6  7
; 8  9  10 11 12 13 14 15
; 16 17 18 19 20 21 22 23
; 24 25 26 27 28 29 30 31
; 32 33 34 35 36 37 38 39
; 40 41 42 43 44 45 46 47
;
; Each box is 35x32 pixels, so each row of each box is 5 consecutive
; bytes in memory once you calculate the HGR base address for that row.
;
BoxesX   ; starting HGR row for each box
         !byte $00,$00,$00,$00,$00,$00,$00,$00
         !byte $20,$20,$20,$20,$20,$20,$20,$20
         !byte $40,$40,$40,$40,$40,$40,$40,$40
         !byte $60,$60,$60,$60,$60,$60,$60,$60
         !byte $80,$80,$80,$80,$80,$80,$80,$80
         !byte $A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0
BoxesY   ; starting byte offset for each box
         !byte $00,$05,$0A,$0F,$14,$19,$1E,$23
         !byte $00,$05,$0A,$0F,$14,$19,$1E,$23
         !byte $00,$05,$0A,$0F,$14,$19,$1E,$23
         !byte $00,$05,$0A,$0F,$14,$19,$1E,$23
         !byte $00,$05,$0A,$0F,$14,$19,$1E,$23
         !byte $00,$05,$0A,$0F,$14,$19,$1E,$23

; The initial grid of stages for each box.
; Each box's stage is incremented on each iteration.
; Negative stages (80..FF) are no-ops.
; Positive stages (00..7F) are indexes into StagesLo/Hi array
; to find the actual drawing routine for this stage (if any).
BoxInitialStages
         !byte $EC,$E8,$E4,$E0,$DC,$D8,$D4,$D0
         !byte $F0,$EC,$E8,$E4,$E0,$DC,$D8,$D4
         !byte $F4,$F0,$EC,$E8,$E4,$E0,$DC,$D8
         !byte $F8,$F4,$F0,$EC,$E8,$E4,$E0,$DC
         !byte $FC,$F8,$F4,$F0,$EC,$E8,$E4,$E0
         !byte $00,$FC,$F8,$F4,$F0,$EC,$E8,$E4

!align $FF,0,0           ; align to page
StagesLo ; low bytes of address of drawing routine for each stage
         !byte <clear00
         !byte <clear01
         !byte <clear02
         !byte <clear03
         !byte <clear04
         !byte <clear05
         !byte <clear06
         !byte <clear07
         !byte <clear08
         !byte <clear09
         !byte <clear0A
         !byte <clear0B
         !byte <clear0C
         !byte <clear0D
         !byte <clear0E
         !byte <clear0F
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte <copy0F
         !byte <copy0E
         !byte <copy0D
         !byte <copy0C
         !byte <copy0B
         !byte <copy0A
         !byte <copy09
         !byte <copy08
         !byte <copy07
         !byte <copy06
         !byte <copy05
         !byte <copy04
         !byte <copy03
         !byte <copy02
         !byte <copy01
         !byte <copy00
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
StagesHi ; high bytes of address of drawing routine for each stage
         !byte >clear00
         !byte >clear01
         !byte >clear02
         !byte >clear03
         !byte >clear04
         !byte >clear05
         !byte >clear06
         !byte >clear07
         !byte >clear08
         !byte >clear09
         !byte >clear0A
         !byte >clear0B
         !byte >clear0C
         !byte >clear0D
         !byte >clear0E
         !byte >clear0F
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte >copy0F
         !byte >copy0E
         !byte >copy0D
         !byte >copy0C
         !byte >copy0B
         !byte >copy0A
         !byte >copy09
         !byte >copy08
         !byte >copy07
         !byte >copy06
         !byte >copy05
         !byte >copy04
         !byte >copy03
         !byte >copy02
         !byte >copy01
         !byte >copy00
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
         !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
